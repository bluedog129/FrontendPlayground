# 문제 접근 방식
백트래킹(재귀):
현재 남은 피로도를 기반으로, 방문하지 않은 던전을 하나씩 탐험합니다.
각 던전을 탐험할 때마다 남은 피로도와 탐험한 던전 수를 업데이트합니다.
탐험 가능한 모든 경로를 탐색하여 최대 탐험 가능한 던전 수를 찾습니다.

기본 구조:
solution 함수에서 방문 여부를 저장하는 배열을 초기화하고, 탐험을 시작합니다.
explore 함수는 현재 피로도와 던전 배열, 방문 여부, 탐험한 던전 수를 인자로 받아 재귀적으로 탐험을 진행합니다.

탐험 과정:
모든 던전을 순회하며, 현재 피로도가 해당 던전의 최소 필요 피로도 이상이고 아직 방문하지 않은 경우 탐험을 시도합니다.
던전을 탐험한 후, 남은 피로도를 갱신하고 탐험한 던전 수를 증가시킵니다.
탐험이 끝나면 방문 상태를 원래대로 되돌리고, 다른 경로를 탐색합니다.

# 시간복잡도
이 알고리즘의 시간 복잡도는 던전의 개수(n)에 따라 달라집니다. 가능한 모든 순서를 시도하기 때문에, 시간 복잡도는 던전의 순열(permutations)의 개수에 따라 결정됩니다.

### 시간 복잡도 분석:

각 던전은 한 번씩 탐험하거나 탐험하지 않는 두 가지 선택이 있습니다.
가능한 모든 던전 탐험 순서의 개수는 n! (n 팩토리얼)입니다.
각 탐험 경로마다, 던전 수만큼의 탐험 시도가 이루어집니다.
따라서, 최악의 경우 시간 복잡도는 O(n * n!)입니다.

### 상세 설명:

순열의 개수:

던전의 모든 가능한 순서는 n! 개입니다.

각 순열 탐험:

각 순열에 대해, 던전을 순서대로 탐험하며 피로도를 확인하고 업데이트합니다.
던전 개수 n에 대해 각각의 순열을 탐험하는 데 O(n)의 시간이 필요합니다.
결론적으로, 시간 복잡도는 O(n * n!)로, 이는 던전의 개수 n이 작을 때만 실행 가능할 정도로 효율적입니다. 주어진 문제의 조건에서 n은 최대 8이므로, 최대 시간 복잡도는 O(8 * 8!) = O(8 * 40,320) = O(322,560)으로, 이는 충분히 계산 가능합니다.